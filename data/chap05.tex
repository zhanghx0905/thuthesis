% !TeX root = ../thuthesis-example.tex

\chapter{总结}

本文设计并实现了一种从 C/C++ 声明自动构建 Cython 包装代码的开发工具，即 CPP2PY。该工具能以有效降低 Cython 语言的学习成本，减少用 Cython 编写 C/C++ 扩展模块时的重复性工作，提高 FFI 开发的生产力。

CPP2PY 接受 C/C++ 头文件为输入，输出接口的 Cython 包装代码、构建脚本和对应 Python 类型注解。本项目经过了详尽的软件测试，覆盖率达到 93 \%。受支持的 C/C++ 语法特性包括函数、全局变量、宏、枚举、类、结构体、联合、类的继承和多态、默认参数、重载、类型别名、异常等。CPP2PY 能处理相当一部分类型在 C++ 和 Python 之间的自动转换，包括基本数值类型及其指针、字符串、部分 STL 容器、枚举、类及其指针等。它还提供了可扩展的自动类型转换模块，只要用户重写转换器基类，指明特定类型数据的转换方法，就能让 CPP2PY 支持新的数据类型。 

基于 CPP2PY，本文封装了 SuiteSpars CHOLMOD 中的大规模稀疏矩阵Cholesky分解模块，为Python科学计算库SciPy实现了正确而高效的稀疏矩阵分解算法，弥补了SciPy和NumPy没有稀疏矩阵Cholesky分解功能的缺憾。封装后的接口与原 C 函数库相比性能损失低于5\%。高性能来源于高度优化的 Cython 编译器，以及类型转换实现中直接操纵指针，避免了整块内存的复制。

C++ 的语法变化复杂，作为一个自动构建工具，CPP2PY 还有诸多未竟之处。未来工作的主要落脚点在两个方面。

首先是支持更多的 C++ 特性。除了第三章中提到的限制之外，CPP2PY 不支持 C++ 模板相关的语法。在 Python 中，并没有与模板对应的语法。但是只要指定模板参数的类型，就能以封装普通类的方式封装模板类。实现模板功能的关键之一在于类型系统，目前 CPP2PY 的类型系统完全基于 libclang，不足以支持模板参数的替换。

其次是支持更多的数据类型，包括函数指针、智能指针等。将 Python 函数对象直接转换成 C 函数指针是不可能的，更合理的做法可能是允许用户将其它 C 函数当作函数指针使用；支持智能指针的难点在于，各种指针类型管理所有权的方式难以相互兼容，指针对象的所有权问题也许只能手动解决。

不得不说，即使是像 SWIG 这样成熟的 FFI 自动构建工具，其能力范围也是有限的。一旦用户的需求超出了这种限度，就不得不开始受工具本身掣肘。需要封装的 C/C++ 程序越复杂，自动生成的接口就越难以使用。相比之下，基于 Cython 语言的 CPP2PY 能提供二次开发的更多可能，尽管同时也带来了 Cython 语法的限制。